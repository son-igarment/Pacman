// This file was generated by Animera

#include <cstddef>
#include <cstdint>

namespace animera {

struct alignas(std::uint64_t) SpriteRect {
  std::uint16_t x = 0, y = 0;
  std::uint16_t w = 0, h = 0;
};

inline namespace sprites {

extern const int texture_width = 512;
extern const int texture_height = 512;
extern const std::size_t texture_pitch = 2048;
extern const std::size_t texture_size = 3945;

extern const unsigned char texture_data[] = {
0xED,0xDD,0xB,0x76,0xA3,0xB8,0x16,0x5,0xD0,0x9A,0xD9,0x1B,0x5A,0xD,0xAD,0x87,
0xE6,0xD7,0xE9,0x8A,0x13,0x42,0xF1,0x11,0xFA,0x5E,0xC1,0xDE,0x6B,0xB1,0xBA,0x8C,
0x65,0x10,0x42,0xBE,0xC7,0xB1,0xB1,0xFB,0xD7,0x2F,0,0,0x68,0xED,0xF5,0xB2,
0x58,0xEA,0x2D,0x30,0xCE,0xBF,0x33,0xF0,0xB5,0xF5,0x6F,0x60,0x4D,0xBD,0xA6,0x36,
0x73,0x8A,0x31,0x3E,0xF2,0x7E,0x6B,0xD9,0x6B,0xB7,0x77,0x7B,0xB9,0x7E,0xC4,0x3A,
0x68,0x4F,0x9D,0xA6,0x15,0x73,0x8B,0xBE,0xF6,0xB2,0x7F,0x2F,0xEB,0x6B,0xAF,0xDB,
0xEB,0xCF,0xD5,0xED,0x41,0x1F,0x6A,0x34,0xAD,0x98,0x5B,0xF4,0x95,0x93,0xFF,0x23,
0x5E,0x27,0xC8,0x7F,0x62,0x50,0xA3,0x69,0xC5,0xDC,0xA2,0xAF,0x96,0xF9,0x5F,0xFB,
0x75,0x42,0xCA,0x67,0x14,0xD0,0x96,0x1A,0x4D,0x2B,0xE6,0x16,0x7D,0x45,0xC8,0xFF,
0x1A,0xED,0xA0,0xF,0x35,0x9A,0x56,0xCC,0x2D,0xFA,0x4B,0xCD,0xD6,0xE8,0xED,0xA0,
0xBD,0x94,0x1A,0xFD,0xA,0xF0,0x7D,0xB2,0x11,0xCB,0x95,0x31,0x7C,0xE2,0x52,0x63,
0x6E,0x41,0x7D,0xAF,0xC4,0x6C,0x8D,0xDE,0xE,0xDA,0x3A,0xAB,0xD1,0x4F,0xAE,0xE1,
0x32,0xEE,0x98,0xB9,0x3,0x30,0xAF,0xA3,0x1A,0xAD,0x7E,0x1B,0x9F,0x33,0xC6,0x7,
0x60,0x4E,0xEA,0xF7,0x31,0xE3,0x73,0xCC,0xF8,0x30,0xAF,0xE5,0x7B,0xEF,0x47,0xEF,
0xC3,0xFF,0xEF,0xD7,0xEF,0xD7,0x72,0xD9,0xDF,0xDE,0x4F,0xBB,0xED,0x56,0x1F,0xA6,
0xE5,0x1F,0x1,0x94,0x50,0xBF,0x8F,0x19,0x9F,0x63,0xC6,0x87,0x58,0xD6,0x9F,0xA9,
0xEF,0x7D,0xC6,0xBE,0xFE,0xC,0x7E,0xAF,0xDD,0x3A,0xFB,0xF7,0x5E,0x3,0xAC,0xB3,
0x7F,0xEF,0x35,0xC0,0xDE,0x5,0x35,0x35,0x8E,0x1D,0xAE,0x51,0xBF,0x8F,0x19,0x9F,
0x63,0xC6,0x87,0x38,0xB6,0x72,0xFC,0x6C,0xDD,0xD1,0x6B,0x80,0x8F,0x9C,0x7F,0x7B,
0xE7,0xFE,0xF2,0xF6,0xF7,0xF6,0x5E,0xDF,0x59,0xFE,0x1D,0xFC,0x5F,0xB7,0xBF,0xDA,
0x2D,0x9A,0x7E,0xE7,0xFE,0x77,0xFB,0x1E,0x63,0x4,0xDF,0xD4,0xEF,0x63,0xC6,0xE7,
0x98,0xF1,0x21,0x8E,0xD4,0x5C,0x1F,0x9D,0xFF,0x7B,0xED,0xFB,0x8D,0x14,0x7C,0x50,
0xBF,0x8F,0x19,0x9F,0x63,0xC6,0x87,0x38,0x5A,0xE4,0xFF,0xD1,0xF2,0xBD,0xBD,0x63,
0x5F,0xED,0x4E,0xBE,0x54,0xDB,0x6F,0xA4,0xE0,0x83,0xFA,0x7D,0xCC,0xF8,0x1C,0x33,
0x3E,0xC4,0xD1,0xF2,0xEF,0xFF,0xB5,0xDD,0xBF,0xFF,0xD7,0x8B,0xFC,0x27,0xAC,0x5A,
0xF5,0xFB,0x70,0x5A,0x6F,0x2C,0x39,0xFD,0xAC,0xB9,0x5C,0xD9,0x6F,0xCE,0x7D,0x51,
0xFA,0x9F,0xBB,0xFF,0x2B,0xDB,0xCD,0xB9,0xF,0xDA,0x38,0xCB,0xF4,0x2B,0xED,0xFC,
0xFD,0xCF,0xBD,0xD5,0xA8,0xDF,0xB9,0x79,0xD4,0xA2,0x6D,0xED,0x6D,0x8E,0x1A,0x9F,
0x9A,0xDB,0x6C,0x79,0x7E,0xE4,0x3F,0xF1,0x9C,0x65,0x7F,0x6A,0xBB,0x77,0xC6,0x2F,
0xB3,0x7E,0x6B,0xDD,0x3B,0xE3,0x7F,0x64,0xFD,0xD6,0xBA,0xCF,0x8C,0x5F,0x66,0xFD,
0xD6,0x3A,0xE8,0xA3,0xB4,0x7E,0x97,0xD4,0xF8,0xD6,0xDB,0x6F,0xBD,0xFF,0xD9,0xFB,
0xDF,0x7A,0xFB,0xF2,0x1F,0x20,0x2E,0xF9,0x9F,0xDF,0x66,0xF6,0xFE,0xB7,0xDE,0xBE,
0xFC,0x7,0x88,0x4B,0xFE,0xE7,0xB7,0x99,0xBD,0xFF,0xAD,0xB7,0x2F,0xFF,0x19,0x23,
0xF5,0x73,0xF5,0xEA,0xED,0x7E,0xFF,0xF3,0x5A,0x2E,0xA5,0xED,0xA0,0x2D,0xF9,0x9F,
0xDF,0x66,0xF6,0xFE,0xB7,0xDE,0xBE,0xFC,0xA7,0xBF,0xD4,0x6B,0xEB,0xAA,0xB7,0x5B,
0x65,0xFA,0x5E,0xB6,0xA7,0xB6,0x83,0xF6,0xE4,0x7F,0x7E,0x9B,0xD9,0xFB,0xDF,0x7A,
0xFB,0xF2,0x9F,0xBE,0x5E,0xBF,0x16,0x97,0xE2,0xBF,0xB3,0x7A,0x71,0xBB,0x59,0xBB,
0x8F,0xC,0xFF,0x6C,0xF2,0x9D,0xE7,0x9F,0xED,0x16,0xD9,0xFE,0x6E,0xF7,0x5E,0xBF,
0xBE,0xDD,0x6F,0xA4,0xE0,0x83,0xFC,0xCF,0x6F,0x33,0x7B,0xFF,0x5B,0x6F,0x5F,0xFE,
0xD3,0xD7,0x3B,0x74,0xFF,0xFB,0xCF,0x22,0xAF,0xDF,0xB7,0x8F,0xDA,0x7D,0xE5,0xF5,
0xAF,0xF5,0xB5,0xF9,0x3F,0xF3,0x7F,0xB3,0x5D,0x62,0xAE,0x6F,0xBD,0x4E,0x58,0xDE,
0xEE,0x37,0x52,0xF0,0x41,0xFE,0xE7,0xB7,0x99,0xBD,0xFF,0xAD,0xB7,0x2F,0xFF,0xE9,
0x6B,0xEF,0xBD,0xFA,0xF5,0x7B,0xF6,0xD5,0xDB,0xED,0xBC,0xA7,0xBF,0x7E,0x6F,0x3F,
0xB5,0x1D,0xF4,0x21,0xFF,0xF3,0xDB,0xCC,0xDE,0xFF,0xD6,0xDB,0x97,0xFF,0xF4,0x25,
0xFF,0xE1,0xA,0xF9,0x9F,0xDF,0x66,0xF6,0xFE,0xB7,0xDE,0xBE,0xFC,0xA7,0x2F,0xF9,
0xF,0x57,0xC8,0xFF,0xFC,0x36,0xB3,0xF7,0xBF,0xF5,0xF6,0xE5,0x3F,0x7D,0xBD,0x33,
0x79,0x9D,0xE1,0xCD,0xD7,0x7D,0x66,0xF7,0x3A,0xEB,0x73,0xD7,0x41,0x1F,0xF2,0x3F,
0xBF,0xCD,0xEC,0xFD,0x6F,0xBD,0x7D,0xF9,0xF,0x10,0x97,0xFC,0xCF,0x6F,0x33,0x7B,
0xFF,0x5B,0x6F,0x5F,0xFE,0x3,0xC4,0x55,0xA3,0x7E,0xE7,0xD4,0xF9,0x2B,0x8F,0x69,
0x91,0x23,0xA5,0xFB,0x9F,0xBD,0xFF,0xB5,0x1E,0x23,0xFF,0x89,0xA7,0xFA,0xEF,0xF0,
0x7D,0x7C,0x47,0x6F,0xB9,0xF4,0x6A,0x7,0x4D,0xD5,0xAA,0xDF,0x87,0x97,0xC9,0x6C,
0x2C,0x39,0xFD,0xAC,0xB9,0x94,0xEE,0x7F,0xF6,0xFE,0xD7,0xDA,0xBE,0xFC,0x27,0x96,
0xEA,0xBF,0xC3,0xB7,0xCE,0xEA,0xBD,0xCC,0xAE,0xDD,0xE,0x9A,0x53,0xBF,0x29,0x61,
0xFE,0x10,0xC7,0xD5,0xDF,0xE1,0x39,0x6B,0xF7,0xEB,0x73,0xD5,0x7F,0x73,0xF9,0x2B,
0xA7,0x3F,0xD7,0x2D,0x33,0xFB,0xFB,0xD1,0x5F,0xED,0x7E,0xDC,0xBE,0xDA,0xE,0xBA,
0x50,0xBF,0x29,0x61,0xFE,0x10,0xC7,0x95,0xDF,0xE1,0x5D,0xAE,0xDF,0x6B,0x77,0x35,
0xD7,0x97,0xAF,0x13,0x7E,0xDC,0x3E,0x68,0xB7,0xF9,0x7A,0x2,0xBA,0x50,0xBF,0x29,
0x61,0xFE,0x10,0x47,0xF5,0xEF,0xE1,0x2F,0x72,0xFF,0xF0,0x3D,0xFB,0xDA,0xED,0xA0,
0xB,0xF5,0x9B,0x12,0xE6,0xF,0x71,0xC8,0x7F,0xB8,0x42,0xFD,0xA6,0x84,0xF9,0x43,
0x1C,0xF2,0x1F,0xAE,0x50,0xBF,0x29,0x61,0xFE,0x10,0x47,0xF5,0xDF,0xE1,0x7B,0x67,
0xF2,0x3A,0xC3,0x5B,0xAF,0x83,0x2E,0xD4,0x6F,0x4A,0x98,0x3F,0,0x73,0x52,0xBF,
0x29,0x61,0xFE,0,0xCC,0xA9,0x56,0xFD,0x7E,0x75,0xFE,0xFD,0x9A,0xD2,0xC7,0x8F,
0x5E,0xA2,0x1F,0xFF,0x95,0xED,0xE6,0xDC,0x7,0xD,0x25,0x7E,0xAE,0xFE,0xFA,0xFD,
0xEF,0xBD,0x8B,0x25,0x5A,0x3B,0x68,0xAB,0x46,0xFD,0xCE,0xCD,0xA3,0x92,0xB6,0xB5,
0x32,0x6A,0x94,0xE8,0xC7,0x5F,0xE3,0xDC,0x47,0x1C,0x77,0x6E,0x2F,0xF1,0xDA,0xBA,
0x75,0x6,0xEF,0x65,0xF1,0xA8,0x76,0xD0,0x5E,0x69,0xFD,0x2E,0xA9,0xF1,0xA5,0xDB,
0x6F,0xDD,0xBF,0xD6,0xA2,0x1F,0x7F,0x8F,0xFE,0x41,0x45,0xAF,0x6F,0xEF,0xDC,0xFF,
0x71,0xFB,0xDD,0xEC,0xF7,0x9F,0x7B,0xFE,0x7B,0xC0,0x57,0xFE,0x7E,0x36,0xFC,0xFD,
0xEB,0xAF,0x76,0xEF,0xF5,0xEB,0xDB,0xAD,0xDA,0x41,0x1F,0x77,0xCF,0x97,0xC8,0x19,
0x14,0xFD,0xF8,0xE5,0x3F,0x93,0x79,0x67,0xFA,0x8F,0xBF,0xFB,0xF7,0xF3,0x3F,0x35,
0xAF,0x97,0xAF,0x13,0x96,0xB7,0x8F,0xDA,0xED,0xBD,0x9E,0x58,0xAE,0xDF,0x6B,0x7,
0x7D,0xDC,0x3D,0x5F,0x22,0x67,0x50,0xF4,0xE3,0x97,0xFF,0x4C,0x66,0x99,0xFB,0x5B,
0xCB,0xBB,0xD9,0xCE,0x7B,0xF0,0xEB,0xF7,0xE2,0x47,0xB5,0x83,0x3E,0xEE,0x9E,0x2F,
0x91,0x33,0x28,0xFA,0xF1,0xCB,0x7F,0x26,0x23,0xFF,0xE1,0x82,0xE8,0xD7,0xFF,0x8D,
0xEA,0x5F,0x6B,0xD1,0x8F,0xDF,0xF5,0x7F,0x4C,0x48,0xFE,0xC3,0x5,0xB5,0xEA,0xF7,
0x9F,0xCF,0xBE,0xD2,0x97,0xE8,0xFD,0x8B,0xB4,0xED,0x9C,0xFB,0x4A,0xFB,0xD8,0xBB,
0x7F,0x50,0xC1,0x3B,0xE3,0x17,0x59,0xBF,0xB5,0xEE,0x9D,0xB5,0x7F,0x7F,0x36,0x1F,
0x63,0x1D,0xF4,0x11,0xBD,0x7E,0x8F,0xEC,0x5F,0x84,0xCF,0x17,0x9C,0x1F,0,0x5A,
0x88,0x5E,0xBF,0x47,0xF7,0xEF,0xE9,0xFB,0x3F,0x13,0xBD,0x7F,0,0x6C,0x8B,0x5E,
0xBF,0x47,0xF7,0xEF,0xE9,0xFB,0x3F,0x13,0xBD,0x7F,0,0x6C,0x8B,0x5E,0xBF,0x47,
0xF7,0xEF,0xE9,0xFB,0x3F,0x13,0xBD,0x7F,0,0x6C,0x8B,0x5E,0xBF,0x47,0xF7,0xEF,
0xE9,0xFB,0x3F,0x13,0xBD,0x7F,0x3C,0xCD,0xFB,0x77,0x78,0x7E,0xAE,0xF9,0x7B,0x2E,
0xBE,0x7F,0xEE,0x67,0xEF,0xF6,0xD5,0x76,0x57,0xFA,0x57,0x73,0x7B,0x90,0x2F,0x7A,
0xFD,0x1E,0xDD,0xBF,0xA7,0xEF,0xFF,0x4C,0xF4,0xFE,0xF1,0x34,0x57,0x72,0x7D,0x39,
0x47,0xFF,0x7E,0xDD,0xB0,0xB7,0xFE,0x38,0xAF,0x5F,0xFF,0xFC,0x7E,0x7D,0x2C,0x67,
0x3D,0x4C,0xDD,0x1E,0xB4,0x13,0xBD,0x7E,0x8F,0xEE,0xDF,0xD3,0xF7,0x7F,0x26,0x7A,
0xFF,0xA0,0xAF,0xF3,0xFC,0x87,0x28,0xCE,0x6A,0xF4,0xE8,0x1A,0x3E,0xBA,0x7F,0x91,
0xBF,0x7F,0xF8,0xF4,0x73,0x3,0x40,0xBE,0xD4,0xEF,0xB8,0xD7,0x5E,0x46,0xF7,0xAF,
0xC6,0xFE,0xAF,0x6E,0xA7,0x76,0x1F,0x5B,0xEF,0xBF,0x67,0xFF,0,0xE8,0x6B,0x54,
0x8D,0x4E,0xDD,0x6F,0xAB,0xFE,0xD5,0xD8,0xFF,0x1D,0x8E,0xA1,0x25,0xF9,0xF,0x10,
0xD7,0xC8,0x1A,0x3D,0xFA,0x6F,0xC8,0xD2,0xFD,0xCF,0xDE,0xFF,0xD6,0xE4,0x3F,0x40,
0x5C,0xD1,0xF3,0x21,0x72,0x7E,0xCE,0xDE,0xFF,0xD6,0xE4,0x3F,0x40,0x5C,0xD1,0xF3,
0x21,0x72,0x7E,0xCE,0xDE,0xFF,0xD6,0xE4,0x3F,0xB1,0xBD,0x56,0xFF,0x87,0xC0,0xD1,
0xFD,0x81,0xBE,0xA2,0xE7,0x43,0xE4,0xFC,0x9C,0xBD,0xFF,0xAD,0xC9,0x7F,0xC6,0x39,
0xFB,0x1E,0xDE,0x3A,0xFB,0xBD,0x6,0xE0,0x99,0x22,0x5F,0x1F,0x36,0xFA,0xDA,0xB9,
0xBD,0xB6,0xB5,0xBF,0xC3,0x90,0x23,0x72,0xFE,0xCB,0x7E,0xC6,0x79,0x67,0xFF,0xDE,
0x6B,0x80,0xBD,0xEC,0xF7,0x1A,0x80,0x67,0x8A,0xFA,0xFD,0xB0,0xD4,0x36,0xB5,0xFB,
0x76,0xB6,0x8F,0xD2,0xC7,0xCF,0x3E,0x7E,0xB5,0xC7,0x17,0xEA,0x58,0x67,0xFF,0xD6,
0x6B,0,0xF9,0xF,0xAD,0x9D,0xE5,0x40,0x8D,0xFC,0xBA,0x73,0xD6,0x18,0x3F,0xB8,
0x4A,0xFE,0x43,0x14,0x47,0xF9,0x52,0x9A,0x5F,0x4F,0xC8,0x2E,0xE3,0x7,0x57,0x79,
0xFF,0x1F,0x22,0x90,0x5F,0x65,0x8C,0x1F,0xE4,0x70,0xFD,0x1F,0x8C,0x26,0xBF,0xCA,
0x18,0x3F,0x68,0x45,0xF6,0x43,0x4B,0xF2,0xAB,0x8C,0xF1,0x3,0x60,0x46,0xF2,0xAB,
0x8C,0xF1,0x3,0x60,0x46,0xF2,0xAB,0x8C,0xF1,0x3,0x60,0x36,0xAD,0xBF,0xBF,0xF6,
0x84,0xFC,0x6A,0x99,0xFF,0xA9,0xDB,0,0xE0,0x7E,0x5A,0xFC,0xF6,0x4B,0xEA,0x6F,
0xC0,0xF4,0xCC,0xFF,0x96,0xC7,0xD0,0x62,0xBB,0x29,0xC7,0x58,0x73,0x8C,0x47,0xCD,
0x1,0,0x9E,0xA7,0x57,0xFE,0xE7,0xE6,0xD0,0xEB,0x54,0xC9,0xB6,0xCB,0xDB,0xD5,
0xCA,0x7F,0,0xE8,0xA9,0x47,0xFE,0x97,0xE4,0x5F,0xCB,0xFC,0x4F,0xED,0x9B,0xFC,
0x7,0xE0,0x6E,0x46,0xE5,0xDF,0xA8,0xF7,0xFF,0x6B,0xF5,0xBF,0xD6,0xE3,0x1,0x62,
0xF8,0xF3,0xF7,0x54,0xFA,0xFD,0xDB,0x7F,0x8F,0xE5,0x6F,0x8F,0xDE,0x46,0xE4,0xDF,
0xC8,0x73,0x9E,0xD3,0x17,0xF9,0x3F,0x2B,0xF5,0xC,0xAE,0xD9,0x9B,0xC3,0xA9,0xCF,
0x85,0xE5,0x7A,0xCF,0x97,0xE8,0x7A,0xE7,0x5F,0x84,0xF3,0x7D,0xB5,0x3F,0xF2,0x7F,
0x66,0xEA,0x19,0x5C,0x73,0xF6,0xDC,0x48,0x7D,0x1E,0x78,0xBE,0x44,0x56,0x7A,0xD,
0x7C,0xCE,0xF5,0x73,0x11,0xCE,0x77,0x4E,0x7F,0x4A,0x8E,0xFF,0x6A,0x5B,0x6A,0x53,
0xCF,0xE0,0x9A,0xA3,0x39,0xEF,0xF9,0x52,0xD3,0x95,0xCF,0xAF,0x6B,0x2E,0xA5,0xFD,
0xBC,0xF2,0xB8,0xAD,0x7F,0x8F,0x92,0xDB,0x9F,0xDA,0xE3,0x17,0xF5,0x3C,0xDF,0x93,
0x7A,0x6,0xD7,0xA4,0xBE,0x77,0xB6,0x77,0xBF,0xE7,0xB,0xF7,0xC9,0x7F,0x66,0xA7,
0x9E,0x41,0x3A,0xCF,0x17,0xCA,0x45,0xCB,0xDB,0x68,0xFD,0xA1,0x17,0xF5,0xC,0xD2,
0x79,0xBE,0x50,0x2E,0x5A,0xDE,0x46,0xEB,0xF,0xBD,0xA8,0x67,0x90,0xCE,0xF3,0x85,
0x72,0xD1,0xF2,0x36,0x5A,0x7F,0xE8,0x45,0x3D,0x83,0x74,0x9E,0x2F,0x94,0x8B,0x96,
0xB7,0xD1,0xFA,0x43,0x2F,0xEA,0x19,0xA4,0xF3,0x7C,0xA1,0x5C,0xB4,0xBC,0x8D,0xD6,
0x1F,0x7A,0x51,0xCF,0x20,0xDD,0xD1,0x7C,0x4E,0x7D,0x2E,0xE5,0x3E,0xE7,0xB8,0x8B,
0x68,0x79,0x1B,0xAD,0x3F,0xF4,0xA2,0x9E,0x41,0xBA,0x94,0xD7,0xBB,0x6B,0x25,0xED,
0xB8,0xA3,0x68,0x79,0x1B,0xAD,0x3F,0xF4,0xA2,0x9E,0x1,0xB1,0xE4,0xFE,0xAE,0x4B,
0xE9,0x52,0xDA,0xCF,0x2B,0x8F,0xDB,0xFA,0xF7,0x28,0xB9,0xFD,0xA9,0x3D,0x7E,0x51,
0xCF,0x33,0x70,0x77,0x57,0x5F,0xB3,0xD6,0x7A,0x6D,0xBC,0x75,0xBF,0xD7,0xD2,0x23,
0xE4,0x66,0xF8,0xD5,0xC7,0xDF,0x21,0xFF,0x4B,0x8E,0xFF,0x6A,0x5B,0x6A,0xD9,0xAA,
0x3D,0x5B,0xB7,0x53,0x6B,0xD2,0x59,0x7D,0x52,0xBB,0x98,0xC5,0x95,0xB9,0x7A,0x94,
0xF5,0x57,0xDB,0x79,0x8E,0x44,0x92,0x72,0x2E,0x8E,0xDA,0x5C,0x7D,0x7C,0x84,0x73,
0x7F,0xB5,0x3F,0x35,0x8F,0x9F,0x9E,0x52,0xF3,0xFF,0xEC,0x71,0xEB,0xF5,0x57,0x1F,
0x7,0xD1,0xA4,0xCE,0xD5,0xB3,0x76,0x67,0xCF,0x89,0xAB,0xED,0xE8,0x69,0x44,0xFE,
0x8D,0x3C,0xFF,0x39,0x7D,0x91,0xFF,0xB3,0x92,0xFF,0xB0,0xAD,0x77,0xFE,0x5F,0xDD,
0x2F,0x3D,0x8C,0xCA,0xBF,0x28,0x9F,0x85,0xCB,0xFF,0x3B,0x6B,0x95,0xFF,0x7B,0x6D,
0xD4,0x36,0x66,0x51,0x3B,0xFF,0x53,0xB7,0xE9,0x39,0x12,0xC9,0xD3,0xF3,0xEF,0xE9,
0xC7,0x7F,0x7F,0xEB,0xBF,0x4F,0x52,0xFE,0x5E,0x91,0xFF,0xDC,0x5D,0x8B,0xFC,0x7F,
0xDF,0x5E,0xBB,0x72,0x3F,0x3D,0xF5,0xC8,0xBF,0x2B,0xED,0x7A,0xAA,0xD1,0x77,0xF9,
0x1F,0x5D,0xAB,0xFC,0x4F,0xB9,0xD,0x51,0xB5,0xCA,0xFF,0xB3,0x36,0x9E,0x23,0x6B,
0x3D,0xDF,0xEF,0xDE,0xDA,0x77,0x49,0x9B,0x2B,0xE7,0x72,0xD4,0x7B,0xFE,0xB9,0x63,
0x53,0xEB,0xF8,0x53,0xDB,0x8C,0x3E,0xCE,0x7B,0x92,0xFF,0xF0,0xB7,0x9E,0xF9,0xBF,
0x6C,0xE7,0x39,0xD2,0xD3,0xD9,0x58,0xF7,0xCC,0xFF,0x59,0xB5,0xCE,0xFF,0x27,0x8C,
0xE1,0x38,0x2D,0xF3,0x7F,0xBD,0x4E,0x6D,0x63,0x16,0xF2,0xFF,0x29,0x5A,0xE6,0xD7,
0x13,0xCE,0xA5,0xF1,0x9B,0xDD,0xD5,0xBF,0xD3,0xE5,0x3F,0x77,0x57,0x3B,0xFF,0x6B,
0xB5,0xA3,0x36,0xF9,0x55,0xC6,0xF8,0xCD,0xAE,0x65,0xFE,0x2F,0xD7,0xAB,0x6D,0xCC,
0xE2,0xCA,0x5C,0xCD,0xFD,0x3C,0x6C,0x6B,0xBD,0xE7,0x48,0x6F,0xF2,0xAB,0x8C,0xF1,
0x9B,0x9D,0xFC,0x87,0x9F,0x5E,0x9,0xCE,0xDA,0xA7,0x6E,0xB7,0x64,0xBF,0x94,0x92,
0x5F,0x65,0x8C,0xDF,0xEC,0xCE,0xF2,0x3F,0xB5,0x26,0x1D,0xD5,0x26,0xB5,0xB,0x88,
0x47,0x7E,0x95,0x31,0x7E,0,0xCC,0x48,0x7E,0x95,0x31,0x7E,0,0xCC,0xC6,0xF7,
0xFF,0xCA,0xF9,0xFE,0x1F,0,0x2D,0x7D,0xE4,0x40,0xED,0x25,0x65,0x9F,0x25,0x6D,
0xAE,0x64,0x57,0x8B,0xE3,0x6B,0x39,0x36,0xB5,0x8E,0x3F,0xB5,0xCD,0xA8,0xE3,0x3,
0x60,0x9C,0x51,0xF5,0xBA,0x57,0xFE,0x47,0xCC,0xA3,0x1A,0x7D,0xAF,0x95,0xFF,0x2D,
0x44,0x1C,0x73,0,0xBE,0x8D,0xAC,0xD3,0x3D,0xF2,0x3F,0x72,0xE,0xDD,0xFD,0xF8,
0x23,0x8F,0x3D,0xC0,0xD3,0x45,0xCF,0x87,0x99,0xF3,0xEF,0xCC,0xDD,0x8F,0x3F,0xF2,
0xD8,0x3,0x3C,0x5D,0xF4,0x7C,0x98,0x39,0xFF,0xCE,0xDC,0xFD,0xF8,0x23,0x8F,0x3D,
0xC0,0xD3,0x45,0xCF,0x87,0x99,0xF3,0xEF,0xCC,0xDD,0x8F,0x3F,0xF2,0xD8,0x3,0x3C,
0xDD,0xC,0xD7,0x87,0x6D,0xB5,0xAD,0x75,0xD,0xFD,0x28,0x4F,0x38,0xFE,0x88,0xE3,
0xE,0xC0,0x1F,0xB3,0x7C,0x3F,0xAC,0xF6,0xE3,0x6B,0x7F,0x47,0xEF,0x8E,0xC7,0x5F,
0x7A,0xC,0xF2,0x1F,0x20,0xAE,0xB3,0x1A,0xFD,0xE4,0x1A,0x2E,0xE3,0x8E,0x99,0x3B,
0,0xF3,0x2A,0xFD,0x7C,0xF9,0xEE,0x8C,0xCF,0x31,0xE3,0x3,0x30,0x27,0xF5,0xFB,
0x98,0xF1,0x39,0x66,0x7C,0,0xE6,0xA4,0x7E,0x1F,0x33,0x3E,0xC7,0x8C,0xF,0xC0,
0x9C,0xD4,0xEF,0x63,0xC6,0xE7,0x98,0xF1,0x1,0x98,0x93,0xFA,0x7D,0xCC,0xF8,0x1C,
0x33,0x3E,0,0x73,0x52,0xBF,0x8F,0x19,0x9F,0x63,0xC6,0x7,0x60,0x4E,0xEA,0xF7,
0x31,0xE3,0x73,0xCC,0xF8,0,0xCC,0xA9,0x56,0xFD,0xEE,0xFD,0xFB,0x37,0xAD,0x7F,
0xBB,0x26,0x65,0xC,0x5A,0xFF,0x46,0xD0,0xC8,0xF1,0xBB,0xB2,0xDD,0x9C,0xFB,0,
0x18,0xAB,0x46,0xFD,0xCE,0xCD,0xA3,0x16,0x6D,0x6B,0x6F,0x73,0xD4,0xF8,0xD4,0xDC,
0x66,0xCB,0xF3,0x23,0xFF,0x1,0xE6,0x54,0x5A,0xBF,0x4B,0x6A,0x7C,0xEB,0xED,0xB7,
0xDE,0xFF,0xEC,0xFD,0x6F,0xBD,0x7D,0xF9,0xF,0x10,0x97,0xFC,0xCF,0x6F,0x33,0x7B,
0xFF,0x5B,0x6F,0x5F,0xFE,0x3,0xC4,0x25,0xFF,0xF3,0xDB,0xCC,0xDE,0xFF,0xD6,0xDB,
0x97,0xFF,0,0x71,0xC9,0xFF,0xFC,0x36,0xB3,0xF7,0xBF,0xF5,0xF6,0xE5,0x3F,0x40,
0x5C,0x23,0xAF,0x6F,0x9B,0xF9,0xFA,0xB9,0x3B,0x5C,0xBF,0xD8,0x7A,0xFB,0xF2,0x1F,
0x20,0xAE,0x96,0xDF,0x6F,0x2B,0xD9,0x77,0xCA,0xF6,0x47,0x7E,0x7F,0xAE,0xF4,0xF1,
0xBD,0xFA,0x9F,0x7A,0x1E,0x5A,0x6C,0x5F,0xFE,0x3,0xC4,0xD5,0xB2,0x7E,0x9F,0x3D,
0x5E,0x3E,0xB4,0xD7,0xFA,0x1C,0xC8,0x7F,0x80,0x39,0xB5,0xAE,0xDF,0xF2,0x61,0x2C,
0xE7,0x17,0x80,0x2D,0xF2,0xE1,0xDE,0x9C,0x5F,0,0xB6,0xC8,0x87,0x7B,0x73,0x7E,
0x1,0xD8,0x22,0x1F,0xEE,0xCD,0xF9,0x5,0x60,0x8B,0x7C,0xB8,0x37,0xE7,0x17,0x80,
0x2D,0xF2,0xE1,0xDE,0x9C,0x5F,0,0xB6,0xF8,0x7E,0xD8,0xBD,0xF9,0x7E,0x27,0,
0x5B,0x66,0xF9,0x7D,0x98,0x68,0xBF,0xBF,0xD3,0xEB,0xF7,0x7B,0x4A,0x8F,0xBF,0xD5,
0xF8,0xA7,0xCE,0x1B,0,0x62,0xCA,0xAD,0xD1,0xA9,0x8F,0xAB,0x91,0x3F,0x5B,0xED,
0x6A,0x65,0xE0,0x28,0xA5,0xFD,0x1F,0x3D,0xFE,0x2D,0x1F,0x7,0x40,0x7B,0x25,0x35,
0xBA,0xF4,0x6F,0xC0,0xD1,0x8F,0x1F,0x6D,0xF4,0xF1,0xB7,0x1E,0xBF,0xC8,0x63,0xF,
0xF0,0x74,0xF2,0x7F,0x9C,0xD1,0xC7,0x2F,0xFF,0x1,0x9E,0x4B,0xFE,0x8F,0x33,0xFA,
0xF8,0xE5,0x3F,0xC0,0x73,0xC9,0xFF,0x71,0x46,0x1F,0xBF,0xFC,0x7,0x78,0xAE,0x1E,
0xD7,0x76,0xCD,0x7A,0xFD,0x5A,0x4B,0xA3,0x8F,0xBF,0xC7,0xF5,0x93,0x11,0xC7,0x1D,
0x80,0x3F,0x52,0xFF,0x6,0xBC,0xE3,0xF7,0xD7,0x6A,0x7D,0x47,0xAF,0xF5,0xB6,0x73,
0xEE,0x3B,0xEB,0xE3,0x55,0x39,0xC7,0x20,0xFF,0x1,0xE2,0x3A,0xAB,0xD1,0xA3,0x6B,
0x78,0xAD,0xFC,0xAB,0xBD,0xEF,0x8,0x7D,0x88,0x7C,0x6E,0x52,0xEE,0x7,0x60,0x9C,
0xC8,0xF9,0x72,0xD6,0x87,0x1E,0xFD,0x7B,0xFA,0xFE,0xCF,0x44,0xEF,0x1F,0,0xDB,
0xA2,0xD7,0xEF,0xD1,0xFD,0x7B,0xFA,0xFE,0xCF,0x44,0xEF,0x1F,0,0xDB,0xA2,0xD7,
0xEF,0xD1,0xFD,0x7B,0xFA,0xFE,0xCF,0x44,0xEF,0x1F,0,0xDB,0xA2,0xD7,0xEF,0xD1,
0xFD,0x7B,0xFA,0xFE,0xCF,0x44,0xEF,0x1F,0,0xDB,0xA2,0xD7,0xEF,0xD1,0xFD,0x7B,
0xFA,0xFE,0xCF,0x44,0xEF,0x1F,0,0xDB,0xA2,0xD7,0xEF,0xD1,0xFD,0x7B,0xFA,0xFE,
0xCF,0x44,0xEF,0x1F,0,0xDB,0x22,0xD7,0xEF,0xA7,0x7F,0xFF,0x2E,0xC2,0xF1,0x97,
0xEC,0x7F,0x74,0xDF,0,0xD8,0x37,0xF2,0xF7,0x75,0x9E,0xFC,0xFB,0x3B,0xA3,0x8F,
0x3F,0xDA,0xF8,0,0xD0,0x57,0x8D,0xFA,0x3D,0x63,0x9D,0xAF,0x71,0x6C,0xC6,0x47,
0xFE,0x3,0xCC,0xAA,0xB4,0x7E,0xCF,0x5C,0xE3,0x4B,0x8F,0xCF,0xF8,0xC8,0x7F,0x80,
0x59,0xC9,0xB7,0xFC,0x36,0xC6,0x47,0xFE,0x3,0xCC,0x4A,0xBE,0xE5,0xB7,0x31,0x3E,
0xF2,0x1F,0x60,0x56,0xF2,0x2D,0xBF,0x8D,0xF1,0x91,0xFF,0,0xB3,0x72,0x7D,0x5B,
0x5E,0xDB,0x5A,0xD7,0xC8,0x47,0xE5,0xFA,0x3F,0x80,0x7B,0x1B,0xF9,0xFD,0xB6,0x91,
0x4B,0xCE,0x38,0xD5,0x7C,0x7C,0xF4,0xE5,0xCA,0x71,0xE5,0xDC,0x7,0xC0,0x58,0xEA,
0x37,0x25,0xCC,0x1F,0x80,0x39,0xA9,0xDF,0x94,0x30,0x7F,0,0xE6,0xA4,0x7E,0x53,
0xC2,0xFC,0x1,0x98,0x93,0xFA,0x4D,0x9,0xF3,0x7,0x60,0x4E,0xEA,0x37,0x25,0xCC,
0x1F,0x80,0x39,0xA9,0xDF,0x94,0x30,0x7F,0,0xE6,0xA4,0x7E,0x53,0xC2,0xFC,0x1,
0x98,0xD3,0x59,0x8D,0x56,0xC3,0xD9,0x63,0xEE,0,0xCC,0x2B,0xA5,0x46,0x8F,0xFE,
0x2D,0x1A,0x4B,0xCC,0xA5,0xC6,0xDC,0x2,0x60,0xC,0x35,0x9A,0x56,0xCC,0x2D,0x80,
0xB8,0xD4,0x68,0x5A,0x31,0xB7,0,0xE2,0x52,0xA3,0x69,0xC5,0xDC,0x2,0x88,0x4B,
0x8D,0xA6,0x15,0x73,0xB,0x20,0x2E,0x35,0x9A,0x56,0xCC,0x2D,0x80,0xD8,0xD4,0x69,
0x6A,0x33,0xA7,0,0xE6,0x30,0xFA,0xBB,0x64,0x96,0x7B,0x2D,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0xD0,0xD7,0xFF,0x1,
};

extern const SpriteRect sprite_rects[] = {
  SpriteRect{},
  SpriteRect{493, 51, 8, 8},
  SpriteRect{463, 61, 8, 8},
  SpriteRect{473, 61, 8, 8},
  SpriteRect{463, 1, 8, 8},
  SpriteRect{473, 1, 8, 8},
  SpriteRect{483, 1, 8, 8},
  SpriteRect{493, 1, 8, 8},
  SpriteRect{503, 1, 8, 8},
  SpriteRect{463, 11, 8, 8},
  SpriteRect{473, 11, 8, 8},
  SpriteRect{483, 11, 8, 8},
  SpriteRect{493, 11, 8, 8},
  SpriteRect{155, 1, 152, 176},
  SpriteRect{309, 1, 152, 176},
  SpriteRect{1, 1, 152, 176},
  SpriteRect{503, 11, 8, 8},
  SpriteRect{463, 21, 8, 8},
  SpriteRect{473, 21, 8, 8},
  SpriteRect{483, 21, 8, 8},
  SpriteRect{493, 21, 8, 8},
  SpriteRect{503, 21, 8, 8},
  SpriteRect{463, 31, 8, 8},
  SpriteRect{473, 31, 8, 8},
  SpriteRect{483, 31, 8, 8},
  SpriteRect{493, 31, 8, 8},
  SpriteRect{503, 31, 8, 8},
  SpriteRect{463, 41, 8, 8},
  SpriteRect{473, 41, 8, 8},
  SpriteRect{483, 41, 8, 8},
  SpriteRect{493, 41, 8, 8},
  SpriteRect{503, 41, 8, 8},
  SpriteRect{463, 51, 8, 8},
  SpriteRect{473, 51, 8, 8},
  SpriteRect{483, 51, 8, 8},
  SpriteRect{503, 51, 8, 8},
};

}

}

/*
* tinflate - tiny inflate
*
* Copyright (c) 2003-2019 Joergen Ibsen
*
* This software is provided 'as-is', without any express or implied
* warranty. In no event will the authors be held liable for any damages
* arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
*
*   1. The origin of this software must not be misrepresented; you must
*      not claim that you wrote the original software. If you use this
*      software in a product, an acknowledgment in the product
*      documentation would be appreciated but is not required.
*
*   2. Altered source versions must be plainly marked as such, and must
*      not be misrepresented as being the original software.
*
*   3. This notice may not be removed or altered from any source
*      distribution.
*/

// Version 1.1.0 with minor changes

#include <memory>
#include <assert.h>
#include <limits.h>

namespace {

#if defined(UINT_MAX) && (UINT_MAX) < 0xFFFFFFFFUL
#  error "tinf requires unsigned int to be at least 32-bit"
#endif

typedef enum {
  TINF_OK         = 0,  /**< Success */
  TINF_DATA_ERROR = -3, /**< Input error */
  TINF_BUF_ERROR  = -5  /**< Not enough room for output */
} tinf_error_code;

/* ------------------------------ *
 * -- internal data structures -- *
 * ------------------------------ */

struct tinf_tree {
  unsigned short table[16]; /* table of code length counts */
  unsigned short trans[288]; /* code -> symbol translation table */
};

struct tinf_data {
  const unsigned char *source;
  unsigned int tag;
  int bitcount;

  unsigned char *dest;
  unsigned int *destLen;

  struct tinf_tree ltree; /* literal/length tree */
  struct tinf_tree dtree; /* distance tree */
};

/* ----------------------- *
 * -- utility functions -- *
 * ----------------------- */

unsigned int read_le16(const unsigned char *p)
{
  return ((unsigned int) p[0])
       | ((unsigned int) p[1] << 8);
}

/* build the fixed huffman trees */
void tinf_build_fixed_trees(struct tinf_tree *lt, struct tinf_tree *dt)
{
  int i;

  /* build fixed length tree */
  for (i = 0; i < 16; ++i) {
    lt->table[i] = 0;
  }

  lt->table[7] = 24;
  lt->table[8] = 152;
  lt->table[9] = 112;

  for (i = 0; i < 24; ++i) {
    lt->trans[i] = 256 + i;
  }
  for (i = 0; i < 144; ++i) {
    lt->trans[24 + i] = i;
  }
  for (i = 0; i < 8; ++i) {
    lt->trans[24 + 144 + i] = 280 + i;
  }
  for (i = 0; i < 112; ++i) {
    lt->trans[24 + 144 + 8 + i] = 144 + i;
  }

  /* build fixed distance tree */
  for (i = 0; i < 16; ++i) {
    dt->table[i] = 0;
  }

  dt->table[5] = 32;

  for (i = 0; i < 32; ++i) {
    dt->trans[i] = i;
  }
}

/* given an array of code lengths, build a tree */
int tinf_build_tree(struct tinf_tree *t, const unsigned char *lengths,
                           unsigned int num)
{
  unsigned short offs[16];
  unsigned int i, sum;

  assert(num < 288);

  /* clear code length count table */
  for (i = 0; i < 16; ++i) {
    t->table[i] = 0;
  }

  /* scan symbol lengths, and sum code length counts */
  for (i = 0; i < num; ++i) {
    t->table[lengths[i]]++;
  }

  t->table[0] = 0;

  /* compute offset table for distribution sort */
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t->table[i];
  }

  /* create code->symbol translation table (symbols sorted by code) */
  for (i = 0; i < num; ++i) {
    if (lengths[i]) {
      t->trans[offs[lengths[i]]++] = i;
    }
  }

  return TINF_OK;
}

/* ---------------------- *
 * -- decode functions -- *
 * ---------------------- */

void tinf_refill(struct tinf_data *d, int num)
{
  assert(num >= 0 && num <= 32);

  /* read bytes until at least num bits available */
  while (d->bitcount < num) {
    d->tag |= (unsigned int) *d->source++ << d->bitcount;
    d->bitcount += 8;
  }

  assert(d->bitcount <= 32);
}

unsigned int tinf_getbits_no_refill(struct tinf_data *d, int num)
{
  unsigned int bits;

  assert(num >= 0 && num <= d->bitcount);

  /* get bits from tag */
  bits = d->tag & ((1UL << num) - 1);

  /* remove bits from tag */
  d->tag >>= num;
  d->bitcount -= num;

  return bits;
}

/* get num bits from source stream */
unsigned int tinf_getbits(struct tinf_data *d, int num)
{
  tinf_refill(d, num);
  return tinf_getbits_no_refill(d, num);
}

/* read a num bit value from stream and add base */
unsigned int tinf_getbits_base(struct tinf_data *d, int num, int base)
{
  return base + (num ? tinf_getbits(d, num) : 0);
}

/* given a data stream and a tree, decode a symbol */
int tinf_decode_symbol(struct tinf_data *d, const struct tinf_tree *t)
{
  int sum = 0, cur = 0, len = 0;

  /* get more bits while code value is above sum */
  do {
    cur = 2 * cur + tinf_getbits(d, 1);

    ++len;

    assert(len <= 15);

    sum += t->table[len];
    cur -= t->table[len];
  } while (cur >= 0);

  assert(sum + cur >= 0 && sum + cur < 288);

  return t->trans[sum + cur];
}

/* given a data stream, decode dynamic trees from it */
int tinf_decode_trees(struct tinf_data *d, struct tinf_tree *lt,
                             struct tinf_tree *dt)
{
  unsigned char lengths[288 + 32];

  /* special ordering of code length codes */
  static const unsigned char clcidx[19] = {
    16, 17, 18, 0,  8, 7,  9, 6, 10, 5,
    11,  4, 12, 3, 13, 2, 14, 1, 15
  };

  unsigned int hlit, hdist, hclen;
  unsigned int i, num, length;
  int res;

  /* get 5 bits HLIT (257-286) */
  hlit = tinf_getbits_base(d, 5, 257);

  /* get 5 bits HDIST (1-32) */
  hdist = tinf_getbits_base(d, 5, 1);

  /* get 4 bits HCLEN (4-19) */
  hclen = tinf_getbits_base(d, 4, 4);

  for (i = 0; i < 19; ++i) {
    lengths[i] = 0;
  }

  /* read code lengths for code length alphabet */
  for (i = 0; i < hclen; ++i) {
    /* get 3 bits code length (0-7) */
    unsigned int clen = tinf_getbits(d, 3);

    lengths[clcidx[i]] = clen;
  }

  /* build code length tree (in literal/length tree to save space) */
  res = tinf_build_tree(lt, lengths, 19);

  if (res != TINF_OK) {
    return res;
  }

  /* decode code lengths for the dynamic trees */
  for (num = 0; num < hlit + hdist; ) {
    int sym = tinf_decode_symbol(d, lt);

    switch (sym) {
    case 16:
      /* copy previous code length 3-6 times (read 2 bits) */
      sym = lengths[num - 1];
      length = tinf_getbits_base(d, 2, 3);
      break;
    case 17:
      /* repeat code length 0 for 3-10 times (read 3 bits) */
      sym = 0;
      length = tinf_getbits_base(d, 3, 3);
      break;
    case 18:
      /* repeat code length 0 for 11-138 times (read 7 bits) */
      sym = 0;
      length = tinf_getbits_base(d, 7, 11);
      break;
    default:
      /* values 0-15 represent the actual code lengths */
      length = 1;
      break;
    }

    while (length--) {
      lengths[num++] = sym;
    }
  }

  /* build dynamic trees */
  res = tinf_build_tree(lt, lengths, hlit);

  if (res != TINF_OK) {
    return res;
  }

  res = tinf_build_tree(dt, lengths + hlit, hdist);

  if (res != TINF_OK) {
    return res;
  }

  return TINF_OK;
}

/* ----------------------------- *
 * -- block inflate functions -- *
 * ----------------------------- */

/* given a stream and two trees, inflate a block of data */
int tinf_inflate_block_data(struct tinf_data *d, struct tinf_tree *lt,
                                   struct tinf_tree *dt)
{
  /* extra bits and base tables for length codes */
  static const unsigned char length_bits[30] = {
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
    1, 1, 2, 2, 2, 2, 3, 3, 3, 3,
    4, 4, 4, 4, 5, 5, 5, 5, 0, 127
  };

  static const unsigned short length_base[30] = {
     3,  4,  5,   6,   7,   8,   9,  10,  11,  13,
    15, 17, 19,  23,  27,  31,  35,  43,  51,  59,
    67, 83, 99, 115, 131, 163, 195, 227, 258,   0
  };

  /* extra bits and base tables for distance codes */
  static const unsigned char dist_bits[30] = {
    0, 0,  0,  0,  1,  1,  2,  2,  3,  3,
    4, 4,  5,  5,  6,  6,  7,  7,  8,  8,
    9, 9, 10, 10, 11, 11, 12, 12, 13, 13
  };

  static const unsigned short dist_base[30] = {
       1,    2,    3,    4,    5,    7,    9,    13,    17,    25,
      33,   49,   65,   97,  129,  193,  257,   385,   513,   769,
    1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577
  };

  /* remember current output position */
  unsigned char *start = d->dest;

  for (;;) {
    int sym = tinf_decode_symbol(d, lt);

    /* check for end of block */
    if (sym == 256) {
      *d->destLen += d->dest - start;
      return TINF_OK;
    }

    if (sym < 256) {
      *d->dest++ = sym;
    }
    else {
      int length, dist, offs;
      int i;

      sym -= 257;

      /* possibly get more bits from length code */
      length = tinf_getbits_base(d, length_bits[sym],
                              length_base[sym]);

      dist = tinf_decode_symbol(d, dt);

      /* possibly get more bits from distance code */
      offs = tinf_getbits_base(d, dist_bits[dist],
                            dist_base[dist]);

      /* copy match */
      for (i = 0; i < length; ++i) {
        d->dest[i] = d->dest[i - offs];
      }

      d->dest += length;
    }
  }
}

/* inflate an uncompressed block of data */
int tinf_inflate_uncompressed_block(struct tinf_data *d)
{
  unsigned int length, invlength;
  unsigned int i;

  /* get length */
  length = read_le16(d->source);

  /* get one's complement of length */
  invlength = read_le16(d->source + 2);

  /* check length */
  if (length != (~invlength & 0x0000FFFF)) {
    return TINF_DATA_ERROR;
  }

  d->source += 4;

  /* copy block */
  for (i = length; i; --i) {
    *d->dest++ = *d->source++;
  }

  /* make sure we start next block on a byte boundary */
  d->tag = 0;
  d->bitcount = 0;

  *d->destLen += length;

  return TINF_OK;
}

/* inflate a block of data compressed with fixed huffman trees */
int tinf_inflate_fixed_block(struct tinf_data *d)
{
  /* build fixed huffman trees */
  tinf_build_fixed_trees(&d->ltree, &d->dtree);

  /* decode block using fixed trees */
  return tinf_inflate_block_data(d, &d->ltree, &d->dtree);
}

/* inflate a block of data compressed with dynamic huffman trees */
int tinf_inflate_dynamic_block(struct tinf_data *d)
{
  /* decode trees from stream */
  int res = tinf_decode_trees(d, &d->ltree, &d->dtree);

  if (res != TINF_OK) {
    return res;
  }

  /* decode block using decoded trees */
  return tinf_inflate_block_data(d, &d->ltree, &d->dtree);
}

/* ---------------------- *
 * -- public functions -- *
 * ---------------------- */

/* inflate stream from source to dest */
int tinf_uncompress(void *dest, unsigned int *destLen,
                    const void *source, unsigned int sourceLen)
{
  struct tinf_data d;
  int bfinal;

  /* initialise data */
  d.source = (const unsigned char *) source;
  d.tag = 0;
  d.bitcount = 0;

  d.dest = (unsigned char *) dest;
  d.destLen = destLen;

  *destLen = 0;

  do {
    unsigned int btype;
    int res;

    /* read final block flag */
    bfinal = tinf_getbits(&d, 1);

    /* read block type (2 bits) */
    btype = tinf_getbits(&d, 2);

    /* decompress block */
    switch (btype) {
    case 0:
      /* decompress uncompressed block */
      res = tinf_inflate_uncompressed_block(&d);
      break;
    case 1:
      /* decompress block with fixed huffman trees */
      res = tinf_inflate_fixed_block(&d);
      break;
    case 2:
      /* decompress block with dynamic huffman trees */
      res = tinf_inflate_dynamic_block(&d);
      break;
    default:
      res = TINF_DATA_ERROR;
      break;
    }

    if (res != TINF_OK) {
      return res;
    }
  } while (!bfinal);

  return TINF_OK;
}

}

namespace animera {

struct TextureInfo {
  const unsigned char *data;
  std::size_t size;
  std::size_t pitch;
  int width;
  int height;
};

std::unique_ptr<const unsigned char []> decompressTexture(const TextureInfo &info) noexcept {
  unsigned dstLen = info.pitch * info.height;
  auto *dst = new unsigned char[dstLen];
  const int ret = tinf_uncompress(dst, &dstLen, info.data, info.size);
  if (ret == TINF_OK) {
    return std::unique_ptr<const unsigned char []>{dst};
  } else {
    return nullptr;
  }
}

}
